[{"slug":"introduction-to-rxjs","category":"blog","title":"Introduction to RxJs","description":"Through out my career I had the opportunity to work with and awesome tool like rxjs, first introduce to me in the angular ecosystem, and then it was a nice library to help in react projects","tags":["rxjs","javascript"],"body":"# RxJS\n\nThrough out my career I had the opportunity to work with and awesome tool like rxjs, first introduce to me in the angular ecosystem, and then it was a nice library to help in react projects. The following is an article with an introduction to the nice parts of RxJs.\n\n[Yeah well honestly with RxJS the benefit is t... - DEV](https://dev.to/ladyleet/comment/2k4a)\n\n> *\"(...)with RxJS the benefit is that you are moving your business logic into a domain specific language - so it's much easier to copy/paste code into new frameworks and libraries without large rewrites. You're also essentially future proofing your code two ways. The first is - RxJS provides an abstraction in the form of Observable for you so that you can easily change out the inputs at a later time. The second is - later on, it's much easier to add on functionality by just adding on another operator or chaining together a set of things, again, without having to rewrite your code much(...)\"*\n> \n\nSource:  [RxJS core team member AM](https://dev.to/ladyleet/im-tracy-lee-a-rxjs-core-team-member-and-google-developer-expert-ask-me-anything-42jo)\n\nRxJS is an implementation of the [ReactiveX](http://reactivex.io/) library for javascript. The main objective of the library is to offer a way **to transform, query and compose asynchronous/event-based sources**. As Tracy Lee (RxJS core team member) states, the library is great to bring a **domain-specific language** to developers. Furthermore, it brings to the table great abstraction and an easier option to handle asynchronous code than the current javascript options.\n\n### Recomended Resources\n\n[learnrxjs.io](https://www.learnrxjs.io/)\n\n[reactivex.io](http://reactivex.io/intro.html)\n\n[rxmarbles](https://rxmarbles.com/)\n\n# Why RxJS\n\nNowadays the common problems of scalability and latency had grown exponentially due to the number of events and data that our javascript programs have to manage to give the best possible interactive UI/UX. There are methods and libraries that try to manage that complexity. For example, callbacks have been mostly used to manage remote source data from endpoints, but this pattern has failed to manage all the problems that managing remote data involves. (2017: Daniels)\n\n## Reactive programming\n\nRxJS its meant to be a solution that follows functional reactive programming to solve **asynchronous data manipulation**. For example, callbacks are a solution to synchronous data management. This solution tries to make **non-blocking code possible** in a way ****that provides a handling way to manage asynchronous code. \n\n### Callbacks\n\nIn the code below, we can see an example of *callback hell.* As we can see, lots of nested functions were put in place to manage different endpoints calls. This makes code unreadable and of course, does not lead to write code in a declarative way.\n\n```jsx\n$.ajax({\n    url: \"http://example.com\",\n    complete: function() {\n        console.log(\"STOP\");\n        $.ajax({\n            url: \"http://example.com\",\n            complete: function() {\n                console.log(\"THIS\");\n                $.ajax({\n                    url: \"http://example.com\",\n                    complete: function() {\n                        console.log(\"MAD\");\n                        $.ajax({\n                            url: \"http://example.com\",\n                            complete: function() {\n                                console.log(\"MAN!\");\n                            }\n                        })\n                    }\n                })\n            }\n        })\n    }\n})\n```\n\nSome of the common drawbacks about callbacks are:\n\n- [Callbacks can run more than once](https://www.codereadability.com/preventing-a-callback-from-accidentally-being-called-twice/)\n- Concurrency becomes complicated\n- Callback Hell\n- Error handling semantics get lost\n\n### Promises\n\nJavascript ES6 introduced another alternative to handle asynchronous code. Promises handle callbacks in a more declarative way in order to give a sense of sequence in  asynchronous operations. This final idea can be sum up with the concept of *continuation*(Rauschmayer:2012)\n\n```jsx\nsomePromise()\n  .then(data => console.log(data))\n  .catch(err => console.error(err))\n```\n\n<figure id=\"0abc6a03-99de-4195-bec9-e7392581789f\" class=\"image\"><a href=\"../../public/images/uploads/quadrant.svg\"><img style=\"width:480px\" src=\"../../public/images/uploads/quadrant.svg\"></a></figure>\n\nPromises solve many raw callbacks drawbacks because they are similar to handling synchronous code, but the only support handling a **single value** throws the flow. So this is where RxJS comes to action. In the following image we can see that observables offer a way to handle multiple values in an asynchronous way, but what is an **observable?** It's an abstraction that can be thought of as an array,  but with the capability of change**,** that means it can **emit different values over time.** \n\n### Streams\n\n> A stream is a sequence of ongoing events ordered in time. It can be anything like user inputs, button clicks or data structures. (2018: Gavhane)\n> \n\nThe concept of stream refers to any kind of event, like an api new data, a button click(s), etc. Conceptually, streams emit a value, an error and complete signal.  Commonly, a stream its represented as a bunch of values over an arrow (Representing time).\n\n\n\n<figure id=\"1e835f66-2db3-4c21-9fa5-f05a3cd7dd98\" class=\"image\"><a href=\"../../public/images/uploads/stream.png\"><img style=\"width:720px\" src=\"../../public/images/uploads/stream.png\"></a></figure>\n\n[Image  from: Andre Staltz, *The introduction to Reactive Programming you've been missing*](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#file-zclickstream-png)\n\n<aside>\nüí° An important initiative, is the [design marble system](https://github.com/BioPhoton/Rx-Marble-Design-System) that it's a framework to standardize the visualization of functional reactive programming.\n\n</aside>\n\nAn  stream is composed by\n\n- Producer: sources of your data and starting point. The [observer pattern](https://en.wikipedia.org/wiki/Observer_pattern) defines produces as *subject,* in RxJS they are called **observables**\n- Consumer: Defined as observer. In RxJS the observers are going to listen through a *subscription* with the `subscribe()` method.\n- Data pipeline: When we pass data from a producer to a consumer we are able to manipulate the data. In RxJS data can be manipulated through *observable operators,* that are similar to the array methods  `map()`, `filter()`  for example.\n- Time\n\n## 1. Observables\n\nObservables are an important concept in RxJS. They can be thinks as: \n\n- As **arrays** that are constructed in a period of time.\n- They represent a stream, a collection of values, a source of data that arrive over time\n- A mere function that takes and observer (the object that listens to values ‚Äã‚Äãdelivered by observables)\n\nThere are plenty of ways to create or define an observable. In the example below, we can see two ways to define them. The first one with the `create()` . With this method, a couple of values are emitted to the subscriber through `next()` inside the arrow function. In the second example, we use `of()` to define an observable from a string value. Then we use the `map()` operator to modify the value of the observable with string interpolation, so the subscriber gets the modified value below.\n\n \n\n```jsx\nimport { of, Observable } from 'rxjs'; \nimport { map } from 'rxjs/operators';\n\n// First way with create method\nconst observable = Observable.create( observer => {\n    observer.next( 'Hello' )\n    observer.next( 'World!' )\n})\n\nobservable.subscribe(val => console.log(val))\n// hello\n// world\n\n// Second way from raw values with the of()\nconst source = of('World').pipe(\n  map(x => `Hello ${x}!`)\n);\n\nsource.subscribe(x => console.log(x));\n// Hello World!\n```\n\n### #from ajax\n\n```jsx\nimport { ajax } from 'rxjs/ajax';\n\nconst someLifeAdvice= `https://api.adviceslip.com/advice`;\n\nconst advice= ajax(someLifeAdvice);\n\nconst subscribe = advice.subscribe(\n  res => console.log(res),\n  err => console.error(err)\n);\n\n/* Output Possible Advice\n\n{\n   \"slip\":{\n      \"advice\":\"Don't give a speech. Put on a show.\",\n      \"slip_id\":\"58\"\n   }\n}\n```\n\n### # from DOM event\n\n```jsx\nconst clicks = fromEvent(document, 'click')\n\n+ clicks.subscribe(console.log) // Sames as .subscribe(click => console.log(click))\n- clicks..subscribe(click => console.log(click))\n// If you click a browser page\n// MouseEvent {isTrusted: true}\n// MouseEvent {isTrusted: true}\n```\n\n### # from Promise\n\n```jsx\nimport { from } from 'rxjs';\n\nconst promise = new Promise((resolve, reject) => { \n    setTimeout(() => {\n        resolve('resolved!')\n    }, 1000)\n});\n//get observable from promise\nconst obsvPromise  = from(promise);\n\n//when whe subscribe to the observable, we will listen to the values emitted\n//output: resolved!\nobsvPromise.subscribe(result => console.log(result))\n```\n\n[https://stackblitz.com/edit/rxjs-x8vqpc?embed=1&file=index.ts](https://stackblitz.com/edit/rxjs-x8vqpc?embed=1&file=index.ts)\n\n## 2. Hot and Cold Observables\n\nYou can think of this two concept in the following wasy:\n\n**Cold observables**: Can only have **one** or a **single** subscription. You can think for example that a youtube video is a cold observable since a single person can see the video at its own pace, so every viewer sees a single instance of the video. Cold observables just **emit values** when **something subscribes** to them, or in this case when someone actually searches and plays a youtube video\n\n**Hot Observables:** **multicast** values, so they are like live youtube video steaming where people only watch the video from the part where the live video is.\n\nTo get a deeper explanation of these concepts you can check [Hot vs Cold observables](https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339), a core RxJS team member post.\n\nCold observable example:\n\n([CodeSandbox](https://codesandbox.io/embed/rxjscold-o06t6?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { Observable } from 'rxjs';\n\nconst cold = Observable.create(observer => observer.next(Math.random()));\n\ncold.subscribe(console.log);\ncold.subscribe(console.log);\n\n//Output two different random values/numbers\n// 0.1653200587\n// 0.8224698752\n\n```\n\nBy moving the source of the value outside the observable creation, we can make the observable hot\n\n([CodeSandbox](https://codesandbox.io/embed/rxjshot-f52gu?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { Observable } from 'rxjs';\n\nrandomNumber = Math.random()\nconst cold = Observable.create(observer => {\n  observer.next(randomNumber)\n});\n\nhot.subscribe(console.log);\nhot.subscribe(console.log);\n\n//Output the same shared value\n// 0.1653200587\n// 0.1653200587\n```\n\nWe can convert a cold observable into a hot one by calling `publish()` . With this method, we can share a source by then calling the `connect()` . So from the cold observable example, we can have a hot observable as following\n\n([CodeSandBox](https://codesandbox.io/embed/rxjscold-r52cg?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { Observable } from 'rxjs';\n\nconst cold = Observable.create(observer => observer.next(Math.random()));\n\nconst hot = cold.publish();\n\ncold.subscribe(console.log);\ncold.subscribe(console.log);\n\nhot.connect()\n\n//Output the same shared value\n// 0.1653200587\n// 0.1653200587\n```\n\n<aside>\nüí° [publish](https://rxjs.dev/api/operators/publish) üìú official docs\n\n</aside>\n\n## 3. Subjects\n\nRxJS lends us a special type of Observable that acts as an event emitter because permits values to be [multicasted](https://en.wikipedia.org/wiki/Multicast). Remember that plain observables are unicast, so instead of converting our cold observables to hot observables, we can use subjects to resolve our use cases.\n\n<aside>\nüí° Subjects act like **observables** and **observers** as the **same time,** since you can subscribe to a Subject and also you can send values to a subject since it implements `next()`, `error()` and `complete()` methods\n\n</aside>\n\n```jsx\nimport { Subject } from 'rxjs';\n\nconst subject = new Subject();\n\nsubject.subscribe(console.log);// logs 1st Value, 2nd Value\n\nsubject.next('1st Value');\nsubject.next('2nd Value');\n\nsubject.subscribe(console.log); // logs 3rd Value, 4th Value\n\nsubject.next('3rd Value');\nsubject.next('4th Value');\n\nsubject.subscribe(console.log); // Doesn't log anything\n\n```\n\nThis example show how subject multicast the values emitted through `next()` method. We can notice that the second subscription will not be logged since for plain subjects each new observer starts receiving the next generated values, r~~emember just like a [Twitch](https://www.twitch.tv/), [facebook](https://www.facebook.com/facebookmedia/solutions/facebook-live) or [youtube](https://www.youtube.com/channel/UC4R8DWoMoI7CAwX8_LjQHig) live stream.~~\n\nThere are other few types of subjects like: ***Behavior subject, Replay subject and Async Subject***\n\n### Behavior Subject\n\nThe behavior subject emits a first value and its capable of emit one previous value to a second subscriber. Its like if the behavior subject had a buffer of size one\n\n```jsx\nimport { Subject, BehaviorSubject } from 'rxjs';\n\nconst behaviorSubject = new BehaviorSubject('1st value');\n\nbehaviorSubject .subscribe(console.log);// prints: 1st value , 2nd value\n\nbehaviorSubject .next('2nd value');\n\nbehaviorSubject .subscribe(console.log); // prints one previous value: 2nd value\n```\n\n## 4. Operators (Most Popular ones) üåä\n\nYou must noticed that to transform certain values emitted by observables we used some methods like `map()` for example. Those methods are called operators. You can think of operators of different kind of tubes that modify the water flow in a pipe system. ~~Yes we know that this example is overly used but it  fulfills its didactic task especially for beginners.~~\n\n<figure id=\"238569bc-9cfd-4bcb-9803-b669045f2b3f\" class=\"image\"><a href=\"../../public/images/uploads/pipes.t9.png\"><img style=\"width:480px\" src=\"../../public/images/uploads/pipes.t9.png\"></a></figure>\n\n### Map\n\nThe map operator applies a function to each emitter value by an observable\n\n([codesandbox](https://codesandbox.io/embed/rxjshot-00k8d?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { range } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\n\nconst obvs = range(0, 10)\n.pipe(map(value => console.log(value + 5)));\n\nobvs.subscribe();\n// the values emitted should be: 5,6,7,8,9,10,11,12,13,14\n```\n\nThis observable gets the first 10 (starting from [0,9] ) numbers and adds them a value of 5.\n\n### Filter\n\n([codesandbox](https://codesandbox.io/embed/rxjsmap-operator-0wdcj?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\n//[learnrxjs.io](https://www.learnrxjs.io/operators/filtering/%27../recipes/%27../recipes/save-indicator.md) example\nimport { interval } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n//emit every second\nconst source = interval(1000);\n//filter out all values until interval is greater than 5\nconst example = source.pipe(filter(num => num > 5));\n/*\n  \"Number greater than 5: 6\"\n  \"Number greater than 5: 7\"\n  \"Number greater than 5: 8\"\n  \"Number greater than 5: 9\"\n*/\nconst subscribe = example.subscribe(val =>\n  console.log(`Number greater than 5: ${val}`)\n);\n```\n\nThe filtering operators pass emitted values to a provided condition. this is really helpful when accepting or denying certain items is important. We will see later that this operators are going to help with the concept of **[backpressure](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/backpressure.md)**\n\n<aside>\nüî• You can find more filtering operators [**here**](https://www.learnrxjs.io/operators/filtering/)\n\n</aside>\n\n### Take\n\nThe most basic example of `take()` operator would be to console.log the first number of an array of numbers:\n\n```jsx\n// learnrxjs.io example\nimport { of } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\n//emit 1,2,3,4,5\nconst source = of(1, 2, 3, 4, 5);\n//take the first emitted value then complete\nconst example = source.pipe(take(1));\n//output: 1\nconst subscribe = example.subscribe(val => console.log(val));\n```\n\nUntil now we have used the operators to show some independent examples of how to use them. In the following one we can see a common counter example to see how we can combine operators:\n\n[https://stackblitz.com/edit/basic-counter?embed=1&file=index.js&hideExplorer=1](https://stackblitz.com/edit/basic-counter?embed=1&file=index.js&hideExplorer=1)\n\nWe are basically showing a stopwatch counter that shows in the page when we click start and pause buttons. We use the `map()` operator to show the milliseconds correctly and we add a `takeUntil()` operator that its a variaton of the `take()` operator.\n\n### Scan\n\nThe **impatient** `reduce()`(yes, similar to the `[array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)`) operator. This operator rushes to show every emitted value in a stream.\n\n```jsx\nimport { merge } from 'rxjs';\nimport { scan } from 'rxjs/operators';\nimport { ajax } from 'rxjs/ajax';\n\nlet progressBar = document.querySelector('.progress-bar');\nlet arrayOfRequests = [];\nlet endpoint = 'https://aws.random.cat/meow';\nfor (let i = 0; i < 128; i++) {\n  arrayOfRequests.push(ajax(endpoint));\n}\n\nmerge(...arrayOfRequests)\n  .pipe(scan(prev => prev + 100 / arrayOfRequests.length, 0))\n  .subscribe(percentDone => {\n    progressBar.style.width = percentDone + '%';\n    progressBar.innerText = Math.round(percentDone) + '%';\n  });\n```\n\nWith scan we can calculate the progress of the requests since scan captures every event emitted.\n\n## 5. Debugging observable streams\n\nIn the previous examples we have seen the use of `.subscribe(console.log)` to print the observables streams. The problem with that it's that we only can see the result at the end of the pipe and not while its been flattened or reduced for example. In the following examples we will show three operators that might be useful for debbuging purposes.\n\n### Tap\n\n([codesandbox](https://codesandbox.io/embed/rxjsscan-operator-wzwz0?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { range } from \"rxjs\";\nimport { map, tap } from \"rxjs/operators\";\n\nconst observable$ = range(0, 10);\n\nconst debbugged$ = observable.pipe(\n  tap(val => console.log(`First tappey üç∫ ${val}`)),\n  map(v => v + 5),\n  tap(v => console.log(`Seccond tap üçª ${v * 2}`)),\n  map(v => v * 2),\n  tap(console.log)\n);\n\ndebbugged$.subscribe();\n```\n\nAs we can see, between `map()` operations we insert `tap()` in order to log the values before and after they have have been modified.\n\n<aside>\nüö® The tap operator was introduced in version six till in previous ones the `do()` operator was the one used as **tap**. The change occurred since do its a reserved word in javascript.\n\n</aside>\n\n### toArray\n\ntoArray is really useful to store the resultant emitted values in a stream. We should be carefull since its waits an stream to complete, so its a good option to use it with operators like \n\n```jsx\nimport { fromEvent } from \"rxjs\";\nimport { take, toArray } from \"rxjs/operators\";\n\nfromEvent(someButton, 'click')\n  .pipe(\n    take(3),\n    toArray()\n  )\n  .subscribe(console.log);\n```\n\n### Repeat\n\nWe can use repeat value to have the observable values as many times desired in order to check how our code is modifying the values and check if that's what we intend.\n\n```jsx\nimport { range, of } from \"rxjs\";\nimport { delay, repeat } from \"rxjs/operators\";\n\nrange(0,3)\n  .pipe(\n    delay(1000),\n    repeat(3)\n  )\n  .subscribe(console.log);\n```\n\n## 6. Backpressure\n\n> *Backpressure occurs when your consumer is slower than your producer. [RxJs docs](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/backpressure.md)*\n> \n\nAs stated in the docs, backpressure refers to when there are more way events(mouse movements, input typing, etc) than the consumers can handle. RxJS bring us some instruments as operators and strategies to attack this problem. To refer to these mechanisms we call them lossy and lossless methods.\n\n**Losless backpressure** refers to when we want to keep the data transmitted as the upload of an image or some file we want to process. Instead, user input events like input [typeahead](https://en.wikipedia.org/wiki/Typeahead) are **lossy** because  we can control the data transmission through operations that are very helpful to batch the data from time to time or pause and restart data streaming between actions.\n\nIn the following example, we can appreciate how we get in the console all the mouse movement positions, so we are going to take this as an example of a lossy backpressure where we get more than what we can process.\n\n### Debounce\n\n([codesandbox](https://codesandbox.io/embed/rxjstap-operator-vm83n?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\n//Fireship.io [RxJs concepts](https://fireship.io/lessons/rxjs-basic-pro-tips/)\n\nimport { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst event = fromEvent(document, 'mousemove').pipe(\n  map(event => {\n    return `X: ${event.clientX} Y: ${event.clientY} üí©`     \n  })\n);\n\nevent.subscribe(console.log)\n```\n\nTo aliviate this we could use the `debounceTime()` operator to wait some time before we start listening the mousemove events. So now we will see that the logging in the console take more time between values. We should notice that all **the values that are between the logged values** or to be more specific, the **values that take less** than the 1000 ms specified as input, are **lost** or **discarded.** Move the mouse around and after one second that we stop moving the position will be logged.\n\n```jsx\n//Fireship.io [RxJs concepts](https://fireship.io/lessons/rxjs-basic-pro-tips/)\n\nimport { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst event$ = fromEvent(document, 'mousemove').pipe(\n  map(event => {\n    return `X: ${event.clientX} Y: ${event.clientY} üí©`     \n  })\n);\n\nconst debounced$ = event.pipe(debounceTime(1000));\n\ndebounced$.subscribe(console.log);\n```\n\nThis strategy is perfect to handle the typeahead kind of use cases where it's better to make backend API call after the user stops typing, so we don't make an API call every time a character is typed\n\n### Throttling\n\nOther approach to handle lossy backpressure is throttling. The `throttleTime` method emits the **first** value between a certain time. For example, we will see in the console one value emitted per second\n\n([codesandbox](https://codesandbox.io/embed/rxjsdebounce-qc6i2?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { fromEvent } from \"rxjs\";\nimport { map, throttleTime } from \"rxjs/operators\";\n\nconst event$ = fromEvent(document, \"mousemove\").pipe(\n  map(event => {\n    return `X: ${event.clientX} Y: ${event.clientY} üí©`;\n  })\n);\n\nconst throttled$ = event.pipe(throttleTime(1000));\n\nthrottled$.subscribe(console.log);\n```\n\n### Buffer\n\nBuffering allows grouping emitted values depending if we select to group them by time, but number of values or by toggle events. \n\n`bufferCount(bufferSize:number, startBufferEvery:number)` will start to group the emmited values in arrays of two values. If you notice the grouped values will not be overlaped since bufferSize = StartBufferEvery \n\n([codesandbox](https://codesandbox.io/embed/rxjsthrottle-0ogkq?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { timer } from \"rxjs\";\nimport { bufferCount } from \"rxjs/operators\";\n\nconst sourceInterval$ = timer(0, 1000); //emit value every second\n\nconst buffered$ = sourceInterval$.pipe(bufferCount(2));// equival to bufferCount(2,2)\n\nbuffered$.subscribe(console.log);\n```\n\nIf for example whe change the bufferSize > startBufferEvery, the values emmited in the arrays will be overlaped\n\n([codesandbox](https://codesandbox.io/embed/rxjsbuffercount1-vl6x3?expanddevtools=1&fontsize=14&hidenavigation=1&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { timer } from \"rxjs\";\nimport { bufferCount } from \"rxjs/operators\";\n\nconst sourceInterval$ = timer(0, 1000); //emit value every second\n\nconst buffered$ = sourceInterval$.pipe(bufferCount(3, 2));\n\nbuffered$.subscribe(console.log);\n```\n\nThere are other for buffering as plain `[buffer](https://www.learnrxjs.io/operators/transformation/buffer.html)`, or `[bufferTime](https://www.learnrxjs.io/operators/transformation/buffertime.html)`. Take a look to those ones as in [learnrxjs.io](http://learnrxjs.io) are great examples of usage.\n\n## 7. Observable Flattening\n\nFlattening solves the problem of observables that emit other observables. A common example is the URL observable\n\n<aside>\nüí° *High - order observables* are the ones that emit other observables\n\n</aside>\n\n```jsx\nimport { from } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { ajax } from 'rxjs/ajax'\n\nlet input$ = from(['url1', 'url2', 'url3']);\nlet output$ = input$.pipe(map((url) => ajax(url)));\n\noutput$.subscribe((innerObservable$) => {\n  innerObservable$.subscribe((data) => console.log(data))\n})\n```\n\nSo the problem with this its that we will need to subscribe separately to each inner observable and the code will start to look like **callback hell. To avoid this problem a much easier solution would be to use the** `mergeAll()` operator\n\n<aside>\nüí° First Order observables are the ones that emit values\n\n</aside>\n\n```jsx\nimport { from } from 'rxjs';\nimport { map,mergeAll } from 'rxjs/operators';\nimport { ajax } from 'rxjs/ajax'\n\nlet input$ = from(['url1', 'url2', 'url3']);\nlet output$ = input$.pipe(\n  map(url => ajax(url)),\n  mergeAll()\n);\noutput$.subscribe(data => console.log(data));\n\n```\n\nWith this we would just need to subscribe to the outer observable (output$) , because behind the scenes `mergeAll` its subscribes to **all** inner observables and remit the values to the outer observable. \n\nWe could also use switching, so with the `switchAll` if we are only interested in the last emitted value for example. A third possibility it's to use concatenation with `concatAll` operator, that will emit the inner observable values in sequence.\n\n<aside>\nüí° Flattening operators allow to **convert** *high- order observables* **into** *firt-order* observables\n\n</aside>\n\n### SwitchMap\n\nSwitching concept its very useful, so are the switching operators like `switchMap`.You can think as this operator it's the combination of `map` + `switchAll`. It's very common to use the operator to avoid race conditions like in a typeahead or autocomplete use cases. Chaining two different HTTP requests that are related it's another user case\n\n```jsx\nimport { of } from 'rxjs'; \nimport { switchMap } from 'rxjs/operators';\n\nconst genre$ = of({ genreID: 'Horror1' });\n\nconst books$ = genre$.pipe(\n    switchMap(genre => {\n        // return an Observable or Promise here\n        return fetch(`http://.../books/${user.genreID}`)\n    })\n)\n\nbooks$.subscribe(console.log);\n// Logs response from the API\n```\n\nFor example to we can implement a search input to check for certain posts in [dev.to](http://dev.to) in order to test the `switchMap` operator\n\n([codesandbox](https://codesandbox.io/embed/rxjsflattening-05nur?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```tsx\nimport { fromEvent, merge, of } from \"rxjs\";\nimport { ajax } from \"rxjs/ajax\";\nimport {\n  map,\n  filter,\n  distinctUntilChanged,\n  debounceTime,\n  tap,\n  switchMap,\n  catchError\n} from \"rxjs/operators\";\n\nlet endpoint = `https://dev.to/api/articles?tag=`;\nlet searchBar = document.querySelector<HTMLElement>(\"input\");\nlet resultsArea = document.querySelector<HTMLElement>(\".results\");\nlet loadingEl = document.querySelector<HTMLElement>(\".loader\");\n\nfunction displayResults(results) {\n  resultsArea.innerHTML = \"\";\n  let listEl = document.createElement(\"ul\");\n  results.forEach(question => {\n    let li = document.createElement(\"li\");\n    let a = document.createElement(\"a\");\n    a.href = question.link;\n    a.innerHTML = question.title;\n    li.appendChild(a);\n    listEl.appendChild(li);\n  });\n  resultsArea.appendChild(listEl);\n}\n\nfromEvent<any>(searchBar, \"keyup\")\n  .pipe(\n    map(event => event.target.value),\n    - filter(query => query.length > 3),\n    - debounceTime(333),\n    tap(() => (loadingEl.style.display = \"block\")),\n    switchMap(query => ajax(endpoint + query)),\n    catchError((err, caught$) => merge(of({ err }), caught$)),\n    tap(() => (loadingEl.style.display = \"none\"))\n  )\n  .subscribe(\n    function updatePageOrErr(results: any) {\n      if (results.err) {\n        alert(results.err);\n      } else {\n        displayResults(results.response);\n      }\n    },\n    err => alert(err.message)\n  );\n```\n\n```html\n<div id=\"app\">\n\t<div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-xs-6 col-xs-offset-3\">\n          <div class=\"text-center\">\n            <h1>Search Dev.to by tag</h1>\n            <input type=\"text\" class=\"form-control\">\n            <h3 class=\"loader\">Loading...</h3>\n            <div class=\"results\"></div>\n          </div>\n        </div>\n      </div>\n    </div>\t\n</div>\n```\n\nWe should avoid nested subscriptions, so thats why we should user operators, in this case `switchMap(query => ajax(endpoint + query))` will get the job done, but we could improve that code by filtering so\nthe word that's in the input has at least 4 words and debouncing to wait some millisenods before start listening to the input changes.\n\nThere is one operator that we are going to follow up in the next section that is `catchError` so we can handle errors smoothly. We also encourage you to try to\nexplore some other operators that could be helpful in this case like `distinctUntilChanged()` and take a look to `contatMap`, `mergeMap` and `exhaustMap` and some of their use cases [Real World RxJS use cases.](https://www.slideshare.net/ladyleet/rxjs-operators-real-world-use-cases-angularmix)\n\n## 8. Combination\n\n<aside>\nüí° \"The combination operators allow the joining of information from multiple observables. Order, time, and structure of emitted values is the primary variation among these operators.\" [learnrxjs.io](https://www.learnrxjs.io/operators/combination/)\n\n</aside>\n\nThis functions allow to combine some\nseries of observables. Commom;y combination functions receive\nobservables as input and return observables that at the end are going to emit an array with values. One of the most used function to combine\nobservables is `combineLatest`.\n\n([codesandbox](https://codesandbox.io/embed/rxjscold-i19ux?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { combineLatest, interval } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\n\nlet counter1 = 0;\nlet counter2 = 1;\n\nconst firstCounter$ = interval(5000).pipe(\n  map(() => {\n    console.log(`Source1: ${counter1}`);\n    return counter1++;\n  })\n);\n\nconst secondCounter$ = interval(5000).pipe(\n  map(() => {\n    console.log(`Source1: ${counter2}`);\n    return counter2++;\n  })\n);\n\nconst combined = combineLatest(firstCounter$, secondCounter$);\n\ncombined.subscribe(val => console.log(`combine latest emits: ${val}`));\n```\n\nIn the example we can see that theresultant observable emits an array with the latest values emitted by\nthe counter observables(`firstCounter$, secondCounter$`). We should consider that combineLatest will start emitting the array only if one of the input values emits at least one value.\n\nA common use case of this function are cascade filtering where we need to wait to two\ncomboboxes or thow checkboxes to be checked in order to make a backend\ncall. Here we can find the [most popular and used combination functions and operators](https://www.learnrxjs.io/operators/combination/).\n\n## 9. Error Handling\n\nTo control the error and notshow to the user any exception that could result from a backend call for examplet, RxJS provide the `catchError` operator. Following the previous switchMap section example, we could add error handling after the ajax calls we make to the dev.to API.\n\n([codesandbox](https://codesandbox.io/embed/rxjsswitchmap-bwih7?expanddevtools=1&fontsize=14&module=%2Fsrc%2Findex.ts))\n\n```jsx\nimport { fromEvent, merge, of } from \"rxjs\";\nimport { ajax } from \"rxjs/ajax\";\nimport { map, tap, switchMap, catchError, take } from \"rxjs/operators\";\n\nlet endpoint = `https://dev.to/api/articles?tag=`;\nlet searchBar = document.querySelector<HTMLElement>(\"input\");\nlet resultsArea = document.querySelector<HTMLElement>(\".results\");\nlet loadingEl = document.querySelector<HTMLElement>(\".loader\");\n\nfunction displayResults(results) {\n  resultsArea.innerHTML = \"\";\n  let listEl = document.createElement(\"ul\");\n  results.forEach(question => {\n    let li = document.createElement(\"li\");\n    let a = document.createElement(\"a\");\n    a.href = question.link;\n    a.innerHTML = question.title;\n    li.appendChild(a);\n    listEl.appendChild(li);\n  });\n  resultsArea.appendChild(listEl);\n}\n\nfromEvent<any>(searchBar, \"keyup\")\n  .pipe(\n    map(event => {\n      if (event.target.value === \"throw error\") {\n        throw \"üí• Booom an error!\";\n      }\n      return event.target.value;\n    }),\n    //filter(query => query.length > 3),\n    //debounceTime(333),\n    tap(() => (loadingEl.style.display = \"block\")),\n    switchMap(query => ajax(endpoint + query)),\n    catchError(err => of({ err: \"Something went wrong, try again\" })),\n    tap(() => (loadingEl.style.display = \"none\"))\n  )\n  .subscribe(\n    function updatePageOrErr(results: any) {\n      if (results.err) {\n        alert(results.err);\n      } else {\n        displayResults(results.response);\n      }\n    },\n    err => alert(err.message)\n  );\n```\n\nIn this example we can see that in the line 36 we added the operator to handle some exception in the observable pipeline, so with this, when we type throw error in the input text, it will generate show in an alert the text \"Something went wrong, try again\". If we wouldn't have this error operator the alert would show an undefined text that doesn't say anything to the user.\n\n<aside>\nüí° After `catchError` operator we can try to add the `retry` that it's very useful when we make API calls\n\n</aside>\n\n## 10. Memory leaks\n\nIt's important to not forget to discard those observables that we don't need anymore, so we can have a performant application and a good usage of memory and CPU. We could do the following to unsubscribe from a observable.\n\n([fireship.io](https://github.com/fireship-io/175-code-this-not-that-rxjs/blob/master/src/10-unsubscribe.js))\n\n```jsx\n//Fireship.io\nimport { interval } from \"rxjs\";\n\nconst source = interval(100);\n\nconst subscription = source.subscribe(value => {\n  console.log(value);\n  if (value >= 10) {\n    subscription.unsubscribe();\n  }\n});\n```\n\nWe can improve this by using some filtering operators so we can manage the unsubscription internally. So if we use takeWhile operator we can achieve the same result because the observable will stop emitting values when the observable reaches the condition.\n\n```jsx\nimport { interval, timer } from \"rxjs\";\nimport { takeLast, takeWhile, takeUntil } from \"rxjs/operators\";\n\nconst source = interval(100);\n\nconst example = source.pipe(\n  takeWhile(v => v <= 10)\n);\n\nexample.subscribe(console.log);\n```\n\nThere are many ways to manage the memory in RxJS, we are going to see in following documents that unsubscribe will have greater protagonism when we use it with some framework lifle cycle hook to try to improve our applications.\n\n## References\n\nDaniels, P. P., & Atencio, L. (2017). *RxJS in action: Covers RxJS 5*. Shelter Island: Manning.\n\nRauschmayer, A. (n.d.). *Asynchronous programming and continuation-passing style in JavaScript.* Retrieved July 17, 2019, from [https://2ality.com/2012/06/continuation-passing-style.html](https://2ality.com/2012/06/continuation-passing-style.html)\n\nDelaney, J. (nd) Rxj: Quickstart with 20 examples Retrieved August 27, 2019 , from [https://angularfirebase.com/lessons/rxjs-quickstart-with-20-examples/](https://angularfirebase.com/lessons/rxjs-quickstart-with-20-examples/)\n\n[https://coursetro.com/courses/25/A-Comprehensive-RxJS-Tutorial---Learn-ReactiveX-for-JavaScript-](https://coursetro.com/courses/25/A-Comprehensive-RxJS-Tutorial---Learn-ReactiveX-for-JavaScript-)\n\n[RxJS Observables Tutorial - Creating & Subscribing to Observables](https://coursetro.com/posts/code/148/RxJS-Observables-Tutorial---Creating-&-Subscribing-to-Observables)\n\n[Angular: Facades + RxJS!](https://blog.angularindepth.com/angular-you-may-not-need-ngrx-e80546cc56ee)\n\nGavhane, S. (2018, September 30) Reactive Programming in JavaScript with RxJS. Retrieved from: [https://dev.to/sagar/reactive-programming-in-javascript-with-rxjs-4jom](https://dev.to/sagar/reactive-programming-in-javascript-with-rxjs-4jom)\n\n## References\n\nDaniels, P. P., & Atencio, L. (2017). *RxJS in action: Covers RxJS 5*. Shelter Island: Manning.\n\nRauschmayer, A. (n.d.). *Asynchronous programming and continuation-passing style in JavaScript.* Retrieved July 17, 2019, from [https://2ality.com/2012/06/continuation-passing-style.html](https://2ality.com/2012/06/continuation-passing-style.html)\n\n[Randall Koutnik](https://learning.oreilly.com/search/?query=author%3A%22Randall%20Koutnik%22&sort=relevance&highlight=true) Koutnik, Randall (2018 )[Build Reactive websites with RxJS](https://www.oreilly.com/library/view/build-reactive-websites/9781680506495/). OReilly, Retrieved August, 2019, from\n\nPoshtaruk, O(2018) [Hands on RxJS for Web development Retrieved](https://www.oreilly.com/library/view/hands-on-rxjs-for/9781788838429/). OReilly, retrieved August 20, 2019, from https://github.com/PacktPublishing/Hands-on-RxJS-for-Web-development\n\nGavhane, S. (2018, September 30) Reactive Programming in JavaScript with RxJS. Retrieved from: [https://dev.to/sagar/reactive-programming-in-javascript-with-rxjs-4jom](https://dev.to/sagar/reactive-programming-in-javascript-with-rxjs-4jom)\n\nDelaney, J. (nd) Rxj: Quickstart with 20 examples Retrieved August 27, 2019 , from [https://angularfirebase.com/lessons/rxjs-quickstart-with-20-examples/](https://angularfirebase.com/lessons/rxjs-quickstart-with-20-examples/)\n\n[Top 10 RxJS concepts](https://fireship.io/lessons/rxjs-basic-pro-tips/)\n\n[Learn ReactiveX for JavaScript](https://coursetro.com/courses/25/A-Comprehensive-RxJS-Tutorial---Learn-ReactiveX-for-JavaScript-)\n\n[RxJS Observables Tutorial - Creating & Subscribing to Observables](https://coursetro.com/posts/code/148/RxJS-Observables-Tutorial---Creating-&-Subscribing-to-Observables)\n\n[Angular: Facades + RxJS!](https://blog.angularindepth.com/angular-you-may-not-need-ngrx-e80546cc56ee)"},{"slug":"launch","category":"blog","title":"Suilad ambar - Let's start bloggin","description":"It's challenging or maybe overwhelming to start a new thing, but I'm tired of thinking of this to much and just launch me to write about the stuff that I do(mostly aboud development)","tags":["blogging","helloworld"],"body":"\n![](https://www.politika.rs/thumbs//upload/Article/Image/2018_02///677z381_kuca-dragutina-matica.jpg)\n\n\n\n**Rytsas vys**¬†‚Äì It's challenging or maybe overwhelming to start a new thing, but I'm tired of thinking of this to much and just launch me to write about the stuff that I do(mostly aboud development). By the way I'm Jesus ü§ô\n\nThis blog is built with astro + svelte and takes Astro - Ink template as an starting point. It's nothing too fancy but it should fill it's purpose.\n\nNext stop should be a post about Nextjs + trpc and my thoughts about it.\n\nThanks for stopping by (‚òûÔæü„ÉÆÔæü)‚òû\n\n```javascript\nfunction MyButton() {\n  return (\n    <button>\n      I'm a button\n    </button>\n  );\n}\n\nexport default function MyApp() {\n  return (\n    <div>\n      <h1>Welcome to my app</h1>\n      <MyButton />\n    </div>\n  );\n}\n```\n\n\n-Jesus\n"},{"slug":"trpc","category":"blog","title":"The new t3 stack","description":"Review of the main points of t3 stack, incluiding pros and cons","tags":["trpc","nextjs"],"body":"\n# T3 stack first steps\n\n> A blog is just like having a long conversation with people, so it should make sense that things you enjoy talking about will be closely related to your passion.\n\n<!-- ## Intro -->\n\n<!-- -   A promise statement\n-   A preview of what's to come -->\n\nThere are lots of opinionanted ways of do things nowdays. From Apollo graphql to NextJs\nThere are plenty of ways to build fullstack apps nowdays with different kind of tech      stacks and i a los of flavors\n\nToday we will try to dive into the [T3 stack](https://init.tips/#why) and basically is a starting point to build a fully typescript app (frontend and backend)\n\n<!-- ## Overview -->\n\nA simple definition as stated in their [github repo](https://github.com/t3-oss/create-t3-app#about)\n\n> *\"(...)The \"T3 Stack\" is a web development stack made by Theo focused on simplicity, modularity, and full-stack typesafety(...)\"*\n>\n\n\n\n> üí° Next.js + tRPC + Tailwind CSS + Typescript + Prisma + NextAuth\n\n\n  To start developing with the t3 stack you can use the cli\n\n\n![](https://upww.screenrec.com/images/f_NSO8uUQ0mwPxaTYtEk2RBJcMgynjADe9.png)\n\n<!-- -   Examples\n-   Transition to the next section -->\n\n<!-- ## Steps -->\n\n  First you are going to be asked about your project name and if you prefer javascript or typescript. Then you are going to be able to select the following optional technologies\n\n  - nextAuth\n  - prisma\n  - tailwind\n  - trpc\n\n  As a software engineer, I am often asked which testing tools are the best to use. The answer to this question depends on the specific requirements of the project. There are many testing tools available, and the best one to use will be determined by the project requirements. T3 create app does not prescribe or recommend anything in this regard, so we must choose which testing tools to use based on our specific requirements. When selecting a toolset, consider the type of software being tested, the project budget, and the timeline for completion.\n\n  For the sake of this article, we are going to select all of the tools in the list.\n  \n  ![](https://upww.screenrec.com/images/f_RtaV1ZzoF8Ii3W7cYqQl5A6MXEuNdygh.png)\n\n  So the basic folder structure is as follows\n\n  ![](https://upww.screenrec.com/images/f_1O4fqujDWBFU3naMh9pbiJmINL2T8lXe.png)\n\n  - Inside `pages/api` folder is where you can find the `/trpc` subfolder where you are going to find the initizialization of the api handlers with the usage of nextjs dynamic routes ([trpc].ts)\n  - `server` folder will contain the boilerplate for the trpc router, and in `utils/trpc` you will find helper types to query resolvers \n\n  \n# Structure of tRPC\n\n  ```\n  T\n   .\n‚îú‚îÄ‚îÄ prisma # <-- if prisma is added\n‚îÇ   ‚îî‚îÄ‚îÄ [..]\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ pages\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _app.tsx # <-- add `withTRPC()`-HOC here\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trpc\n‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [trpc].ts # <-- tRPC HTTP handler\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [..]\n‚îÇ   ‚îú‚îÄ‚îÄ server\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routers\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.ts   # <-- main app router\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ post.ts  # <-- sub routers\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [..]\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ context.ts      # <-- create app context\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ createRouter.ts # <-- router helper\n‚îÇ   ‚îî‚îÄ‚îÄ utils\n‚îÇ       ‚îî‚îÄ‚îÄ trpc.ts  # <-- your typesafe tRPC hooks\n‚îî‚îÄ‚îÄ [..]\n\n    /*Source: trpc docs*/\n  ```\n\n\n> üí° You can find the complete folder structure suggenstion in the [trpc docs](https://trpc.io/docs/v10/nextjs)\n\n\nIn `createRouter.ts` you will define the creation of the router for trpc so you can start merging the rrouter in the main app router that in this case is inside `server/routers/app.ts`\n\nInside the `server/routers` you could start defining your router methods for specific entities as in the `post.ts` example.\n\nThe `context.ts` is also important because here we define all the objects that are going to be available in every api call, like for example the session object, to check if a user is authenticated/authorized, or the prisma client, so you we can access the data through prisma.\n\nFinally to add trpc to you nextjs app, you would need to wrap you entry point with the `withTRPC` HOC. The HOC has a config callback that is going to be very importanto to make custom customizations about the API url, or the react-query configuration that internally is used by tRPC react hooks.\n\nFor example this is how a router would look like in the `server/routers` \n\n``` javascript\nimport { Prisma, CandidateRecruiterLink } from '@prisma/client';\nimport {\n  createLinkSchema,\n  verifyLinkSchema,\n  verifyLinkUsageResponseSchema,\n  verifyLinkUsageSchema,\n} from '../../../schema/link.schema';\nimport { createRouter } from '../createRouterContext';\n\nexport const linkRouter = createRouter()\n  .mutation('create-link', {\n    input: createLinkSchema,\n    async resolve({ ctx, input }) {\n      const link = await ctx.prisma.candidateRecruiterLink.create({\n        data: {\n          minSalary: input.minSalary,\n          isAnual: input.salaryPeriod === 'anual',\n          isNetSalary: input.salaryType === 'net',\n          currency: input.salaryCurrency,\n          comment: input.comment,\n        },\n      });\n\n      return link;\n    },\n  })\n  .mutation('verify-link', {\n    input: verifyLinkSchema,\n    async resolve({ ctx, input }) {\n      console.log('üöÄ ~ file: link.router.ts ~ line 30 ~ resolve ~ input', {\n        input,\n      });\n\n      const link = await ctx.prisma.candidateRecruiterLink.findFirst({\n        where: {\n          matchId: input.slug,\n        },\n      });\n\n      console.log({ link });\n\n      const maxSalary = new Prisma.Decimal(input.maxSalary);\n      let isMatch = false;\n      if (link) {\n        await ctx.prisma.candidateRecruiterLink.update({\n          where: {\n            matchId: input.slug,\n          },\n          data: { maxSalary },\n        });\n        isMatch = maxSalary >= link.minSalary;\n      }\n      return {\n        isMatch,\n        maxSalary: input.maxSalary,\n        minSalary: link?.minSalary || 0,\n      };\n    },\n  })\n  .query('verify-link-usage', {\n    input: verifyLinkUsageSchema,\n    async resolve({ ctx, input }) {\n      const link = await ctx.prisma.candidateRecruiterLink.findFirst({\n        where: {\n          matchId: input.slug,\n        },\n      });\n\n      console.log({ link });\n\n      let alreadyUsed = false;\n      if (link?.maxSalary) {\n        alreadyUsed = true;\n      }\n\n      return {\n        currency: link?.currency,\n        salaryType: link?.isNetSalary ? 'Net' : 'Gross',\n        salaryPeriod: link?.isAnual ? 'Anual' : 'Monthly',\n        alreadyUsed,\n      };\n    },\n  });\n\n```\n\nThe magic here is that you can define schemas to type the API endpoints and also to have those types available through all our monorepo.\n\n\n> üßô‚Äç‚ôÇÔ∏è  Full static typesafety & autocompletion on the client, for inputs, outputs and errors. - tRPC docs\n\n``` javascript\nimport z from 'zod';\nimport { CandidateRecruiterLink } from '@prisma/client';\n\nexport const createLinkSchema = z.object({\n  minSalary: z.number().min(0),\n  salaryType: z.enum(['gross', 'net']),\n  salaryPeriod: z.enum(['anual', 'monthly']),\n  salaryCurrency: z.enum(['USD', 'EUR', 'GBP']),\n  comment: z.string(),\n  slug: z.string(),\n});\n\nexport type CreateLinkInput = z.TypeOf<typeof createLinkSchema>;\n\nexport const getSingleLinkSchema = z.object({\n  linkId: z.string().cuid(),\n});\n\nexport const verifyLinkSchema = z.object({\n  maxSalary: z.number(),\n  slug: z.string(),\n});\n\nexport const verifyLinkUsageSchema = z.object({\n  slug: z.string(),\n});\n\nexport const verifyLinkUsageResponseSchema = z.object({\n  alreadyUsed: z.string(),\n  isNetSalary: z.boolean(),\n  isAnual: z.boolean(),\n  currency: z.string(),\n  comment: z.string(),\n  slug: z.string().nullish(),\n});\n```\n\n\n\n<!-- # Conclusion -->\n\nSo this is a first view of tRPC and the very basics of what you can accomplish a fullstack app with the T3 stack.\n\nIt's important that the T3 stack is awesome to start a project and save time with the initial setup of a fully typed app. \n\n\nThis is the [github repo](https://github.com/gzuzmark/remotool) of the examples shown above \n\n\n<!-- \n    - Reminder of how helpful the guide is \n    - Reiterate how important your topic is\n    - Call-to-action\n--->\n\n\nI would recommend the following tutorials if you want to learn more about trpc\n\n- [tRPC: Smart and Easy APIs](https://www.youtube.com/watch?v=Lam0cYOEst8)\n- [Build a Blog With the T3 Stack - tRPC, TypeScript, Next.js, Prisma & Zod](https://www.youtube.com/watch?v=syEWlxVFUrY&t=1389s)\n\n<!-- \n# Checklist\n\nInspiration ‚õÖ\n\n-   Read articles and watch videos that inspire me\n-   Brainstorm the topics that I want to write about in bullet points\n-   Reorder those bullet points to create a line of thought\n\nDraft ‚úèÔ∏è\n\n-   Expand those bullet points into sentences/text\n-   Go over the document\n\nReady to Publish üåê\n\n-   Draft 5 titles and pick one\n-   Revise the complete text for typos\n-   Preview the text\n-   Publish or schedule the post\n-   Promote on social media\n\n-->\n\n"}]